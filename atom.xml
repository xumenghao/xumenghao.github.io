<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>James Xu</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="xumenghao.top/"/>
  <updated>2018-03-21T03:30:00.624Z</updated>
  <id>xumenghao.top/</id>
  
  <author>
    <name>James Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端常见跨域解决方案</title>
    <link href="xumenghao.top//posts/4a17b157/"/>
    <id>xumenghao.top//posts/4a17b157/</id>
    <published>2018-03-22T06:19:57.576Z</published>
    <updated>2018-03-21T03:30:00.624Z</updated>
    
    <content type="html"><![CDATA[<p>学习下跨域</p><a id="more"></a><h4 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h4><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p><p>广义的跨域：</p><p> 1.资源跳转： A链接、重定向、表单提交<br> 2.资源嵌入：<code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;frame&gt;</code>等dom标签，还有样式中<code>background:url()</code>、<code>@font-face()</code>等文件外链<br> 3.脚本请求： js发起的ajax请求、dom和js对象的跨域操作等</p><p>其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。</p><p>什么是同源策略？</p><p>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>同源策略限制以下几种行为：</p><p> 1.Cookie、LocalStorage 和 IndexDB 无法读取<br> 2.DOM 和 Js对象无法获得<br> 3.AJAX 请求不能发送</p><h4 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h4><blockquote><p>URL                                      说明                    是否允许通信<br><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://www.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/b.js</a>         同一域名，不同文件或路径           允许<br><a href="http://www.domain.com/lab/c.js" target="_blank" rel="noopener">http://www.domain.com/lab/c.js</a></p><p><a href="http://www.domain.com:8000/a.js" target="_blank" rel="noopener">http://www.domain.com:8000/a.js</a><br><a href="http://www.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/b.js</a>         同一域名，不同端口                不允许<br><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="https://www.domain.com/b.js" target="_blank" rel="noopener">https://www.domain.com/b.js</a>        同一域名，不同协议                不允许<br><a href="http://192.168.4.12/b.js" target="_blank" rel="noopener">http://192.168.4.12/b.js</a>           域名和域名对应相同ip              不允许<br><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://x.domain.com/b.js" target="_blank" rel="noopener">http://x.domain.com/b.js</a>           主域相同，子域不同                不允许<br><a href="http://domain.com/c.js" target="_blank" rel="noopener">http://domain.com/c.js</a><br><a href="http://www.domain1.com/a.js" target="_blank" rel="noopener">http://www.domain1.com/a.js</a><br><a href="http://www.domain2.com/b.js" target="_blank" rel="noopener">http://www.domain2.com/b.js</a>        不同域名                         不允许</p></blockquote><h4 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h4><p> 1.通过jsonp跨域<br> 2.document.domain + iframe跨域<br> 3.location.hash + iframe<br> 4.window.name + iframe跨域<br> 5.postMessage跨域<br> 6.跨域资源共享（CORS）<br> 7.nginx代理跨域<br> 8.nodejs中间件代理跨域<br> 9.WebSocket协议跨域</p><h4 id="一、通过jsonp跨域"><a href="#一、通过jsonp跨域" class="headerlink" title="一、通过jsonp跨域"></a>一、通过jsonp跨域</h4><p> 通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p><p> 1.原生实现：</p><blockquote></blockquote><p><code>&lt;script&gt;</code><br>   &nbsp;&nbsp; var script = document.createElement(‘script’);<br>   &nbsp;&nbsp; script.type = ‘text/javascript’;<br>   &nbsp;&nbsp; // 传参并指定回调执行函数为onBack<br>   &nbsp;&nbsp; script.src = ‘<a href="http://www.domain2.com:8080/login" target="_blank" rel="noopener">http://www.domain2.com:8080/login</a>?  user=admin&amp;callback=onBack’;<br>    document.head.appendChild(script);<br>    // 回调执行函数<br>   &nbsp;&nbsp;function onBack(res) {<br>   &nbsp;&nbsp;&nbsp;&nbsp;     alert(JSON.stringify(res));<br>   &nbsp;&nbsp;}<br><code>&lt;/script&gt;</code><br>服务端返回如下（返回时即执行全局函数）：</p><blockquote><p>onBack({“status”: true, “user”: “admin”})  </p></blockquote><p>2.jquery ajax：</p><blockquote><p>$.ajax({<br>&nbsp;&nbsp;    url: ‘<a href="http://www.domain2.com:8080/login&#39;" target="_blank" rel="noopener">http://www.domain2.com:8080/login&#39;</a>,<br>&nbsp;&nbsp;    type: ‘get’,<br>&nbsp;&nbsp;    dataType: ‘jsonp’,  // 请求方式为jsonp<br>&nbsp;&nbsp;    jsonpCallback: “onBack”,    // 自定义回调函数名<br>&nbsp;&nbsp;    data: {}<br>});  </p></blockquote><p>3.vue.js：  </p><blockquote><p>this.$http.jsonp(‘<a href="http://www.domain2.com:8080/login&#39;" target="_blank" rel="noopener">http://www.domain2.com:8080/login&#39;</a>, {<br>&nbsp;&nbsp;    params: {},<br>&nbsp;&nbsp;    jsonp: ‘onBack’<br>}).then((res) =&gt; {<br>&nbsp;&nbsp;    console.log(res);<br>})  </p></blockquote><p>后端node.js代码示例：  </p><blockquote><p>var querystring = require(‘querystring’);<br>var http = require(‘http’);<br>var server = http.createServer();  </p><p>server.on(‘request’, function(req, res) {<br>&nbsp;&nbsp;    var params = qs.parse(req.url.split(‘?’)[1]);<br>&nbsp;&nbsp;    var fn = params.callback;  </p><p>&nbsp;&nbsp;    // jsonp返回设置<br>&nbsp;&nbsp;    res.writeHead(200, { ‘Content-Type’: ‘text/javascript’ });<br>&nbsp;&nbsp;    res.write(fn + ‘(‘ + JSON.stringify(params) + ‘)’);<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;    res.end();<br>});  </p><p>server.listen(‘8080’);<br>console.log(‘Server is running at port 8080…’);  </p></blockquote><p>jsonp缺点：只能实现get一种请求。</p><h4 id="二、-document-domain-iframe跨域"><a href="#二、-document-domain-iframe跨域" class="headerlink" title="二、 document.domain + iframe跨域"></a>二、 document.domain + iframe跨域</h4><p>此方案仅限主域相同，子域不同的跨域应用场景。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>1.父窗口：(<a href="http://www.domain.com/a.html" target="_blank" rel="noopener">http://www.domain.com/a.html</a>)</p><blockquote></blockquote><p><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;</code><br><code>&lt;script&gt;</code><br>    &nbsp;&nbsp;document.domain = ‘domain.com’;<br>   &nbsp;&nbsp;var user = ‘admin’;<br><code>&lt;/script&gt;</code></p><p>2.子窗口：(<a href="http://child.domain.com/b.html" target="_blank" rel="noopener">http://child.domain.com/b.html</a>)</p><blockquote></blockquote><p><code>&lt;script&gt;</code><br>   &nbsp; document.domain = ‘domain.com’;<br>   &nbsp; // 获取父窗口中变量<br>   &nbsp; alert(‘get js data from parent —&gt; ‘ + window.parent.user);<br><code>&lt;/script&gt;</code></p><h4 id="三、-location-hash-iframe跨域"><a href="#三、-location-hash-iframe跨域" class="headerlink" title="三、 location.hash + iframe跨域"></a>三、 location.hash + iframe跨域</h4><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><p>1.a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">http://www.domain1.com/a.html</a>)</p><blockquote></blockquote><p><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</code><br><code>&lt;script&gt;</code><br>   &nbsp; var iframe = document.getElementById(‘iframe’);<br>   &nbsp; // 向b.html传hash值<br>   &nbsp; setTimeout(function() {<br>   &nbsp;&nbsp;     iframe.src = iframe.src + ‘#user=admin’;<br>   &nbsp;}, 1000);<br>   &nbsp; // 开放给同域c.html的回调方法<br>   &nbsp;&nbsp;     alert(‘data from c.html —&gt; ‘ + res);<br>   &nbsp; }<br><code>&lt;/script&gt;</code><br>2.b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">http://www.domain2.com/b.html</a>)</p><blockquote></blockquote><p><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</code><br><code>&lt;script&gt;</code><br>   &nbsp; var iframe = document.getElementById(‘iframe’);<br>   &nbsp; // 监听a.html传来的hash值，再传给c.html<br>   &nbsp; window.onhashchange = function () {<br>   &nbsp;&nbsp;     iframe.src = iframe.src + location.hash;<br>   &nbsp; };<br><code>&lt;/script&gt;</code><br>3.c.html：(<a href="http://www.domain1.com/c.html" target="_blank" rel="noopener">http://www.domain1.com/c.html</a>)</p><p><code>&lt;script&gt;</code><br>    // 监听b.html传来的hash值<br>   &nbsp; window.onhashchange = function () {<br>     &nbsp;&nbsp; // 再通过操作同域a.html的js回调，将结果传回<br>     &nbsp;&nbsp;window.parent.parent.onCallback  (‘hello:’+location.hash.replace(‘#user=’,’’));<br>    &nbsp;};<br><code>&lt;/script&gt;</code></p><h4 id="四、-window-name-iframe跨域"><a href="#四、-window-name-iframe跨域" class="headerlink" title="四、 window.name + iframe跨域"></a>四、 window.name + iframe跨域</h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>1.a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">http://www.domain1.com/a.html</a>)</p><blockquote><p>var proxy = function(url, callback) {<br>&nbsp;&nbsp;   var state = 0;<br>&nbsp;&nbsp;    var iframe = document.createElement(‘iframe’);  </p><p>&nbsp;&nbsp;    // 加载跨域页面<br>&nbsp;&nbsp;    iframe.src = url;  </p><p>&nbsp;&nbsp;    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name<br>&nbsp;&nbsp;    iframe.onload = function() {<br>&nbsp;&nbsp;&nbsp;        if (state === 1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据<br>&nbsp;&nbsp;&nbsp;&nbsp;            callback(iframe.contentWindow.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;            destoryFrame();  </p><p>&nbsp;&nbsp;&nbsp;        } else if (state === 0) {<br>&nbsp;&nbsp;&nbsp;            // 第1次onload(跨域页)成功后，切换到同域代理页面<br>&nbsp;&nbsp;&nbsp;            iframe.contentWindow.location = ‘<a href="http://www.domain1.com/proxy.html&#39;" target="_blank" rel="noopener">http://www.domain1.com/proxy.html&#39;</a>;<br>&nbsp;&nbsp;&nbsp;            state = 1;<br>&nbsp;&nbsp;&nbsp;        }<br>&nbsp;&nbsp;    };  </p><p>&nbsp;    document.body.appendChild(iframe);  </p><p>&nbsp;&nbsp;    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）<br>&nbsp;&nbsp;    function destoryFrame() {<br>&nbsp;&nbsp;&nbsp;&nbsp;        iframe.contentWindow.document.write(‘’);<br>&nbsp;&nbsp;&nbsp;&nbsp;        iframe.contentWindow.close();<br>&nbsp;&nbsp;&nbsp;&nbsp;        document.body.removeChild(iframe);<br>&nbsp;&nbsp;    }<br>};  </p><p>// 请求跨域b页面数据<br>proxy(‘<a href="http://www.domain2.com/b.html&#39;" target="_blank" rel="noopener">http://www.domain2.com/b.html&#39;</a>, function(data){<br>&nbsp;&nbsp;    alert(data);<br>});  </p></blockquote><p>2.proxy.html：(<a href="http://www.domain1.com/proxy…" target="_blank" rel="noopener">http://www.domain1.com/proxy…</a>.<br>中间代理页，与a.html同域，内容为空即可。</p><p>3.b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">http://www.domain2.com/b.html</a>)</p><blockquote></blockquote><p><code>&lt;script&gt;</code><br>   &nbsp;&nbsp; window.name = ‘This is domain2 data!’;<br><code>&lt;/script&gt;</code><br>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h4 id="五、-postMessage跨域"><a href="#五、-postMessage跨域" class="headerlink" title="五、 postMessage跨域"></a>五、 postMessage跨域</h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/”。</p><p>1.a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">http://www.domain1.com/a.html</a>)</p><blockquote></blockquote><p><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</code><br><code>&lt;script&gt;</code><br>    &nbsp;var iframe = document.getElementById(‘iframe’);<br>    &nbsp;iframe.onload = function() {<br>        &nbsp;&nbsp;var data = {<br>            &nbsp;&nbsp;&nbsp;name: ‘aym’<br>        &nbsp;};<br>       &nbsp; // 向domain2传送跨域数据<br>        &nbsp;iframe.contentWindow.postMessage(JSON.stringify(data),’<a href="http://www.domain2.com&#39;)" target="_blank" rel="noopener">http://www.domain2.com&#39;)</a>;<br>    };<br>   &nbsp; // 接受domain2返回数据<br>   &nbsp; window.addEventListener(‘message’, function(e) {<br>    &nbsp;&nbsp;    alert(‘data from domain2 —&gt; ‘ + e.data);<br>    &nbsp;&nbsp;}, false);<br><code>&lt;/script&gt;</code><br>2.）b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">http://www.domain2.com/b.html</a>)</p><blockquote></blockquote><p><code>&lt;script&gt;</code><br>// 接收domain1的数据<br>window.addEventListener(‘message’, function(e) {<br> &nbsp;&nbsp;alert(‘data from domain1 —&gt; ‘ + e.data);  </p><blockquote><pre><code>   var data = JSON.parse(e.data);     &amp;nbsp;  if (data) {          &amp;nbsp;&amp;nbsp;data.number = 16;         &amp;nbsp;&amp;nbsp; // 处理后再发回domain1         &amp;nbsp;&amp;nbsp; window.parent.postMessage(JSON.stringify  (data), &amp;nbsp;&amp;nbsp;&amp;nbsp;&apos;http://www.domain1.com&apos;);     &amp;nbsp;&amp;nbsp; }  }, false);  </code></pre><p><code>&lt;/script&gt;</code></p></blockquote><h4 id="六、-跨域资源共享（CORS）"><a href="#六、-跨域资源共享（CORS）" class="headerlink" title="六、 跨域资源共享（CORS）"></a>六、 跨域资源共享（CORS）</h4><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置。<br>带cookie请求：前后端都需要设置字段，另外需注意：所带cookie为跨域请求接口所在域的cookie，而非当前页。<br>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p><p>一、前端设置：</p><p>1.原生ajax</p><blockquote><p>// 前端设置是否带cookie<br>xhr.withCredentials = true;  </p></blockquote><p>示例代码：  </p><blockquote><p>var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容  </p><p>// 前端设置是否带cookie<br>xhr.withCredentials = true;  </p><p>xhr.open(‘post’, ‘<a href="http://www.domain2.com:8080/login&#39;" target="_blank" rel="noopener">http://www.domain2.com:8080/login&#39;</a>, true);<br>xhr.setRequestHeader(‘Content-Type’, ‘application/x-www-form-urlencoded’);<br>xhr.send(‘user=admin’);  </p><p>xhr.onreadystatechange = function() {<br>&nbsp;&nbsp;    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {<br>&nbsp;&nbsp;&nbsp;&nbsp;        alert(xhr.responseText);<br>&nbsp;&nbsp;    }<br>};  </p></blockquote><p>2.jQuery ajax</p><blockquote><p>$.ajax({<br>&nbsp;&nbsp;    …<br>&nbsp;&nbsp;   xhrFields: {<br>&nbsp;&nbsp;&nbsp;&nbsp;       withCredentials: true    // 前端设置是否带cookie<br>&nbsp;&nbsp;   },<br>&nbsp;&nbsp;   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie<br>&nbsp;&nbsp;    …<br>});  </p></blockquote><p>3.vue框架</p><p>在vue-resource封装的ajax组件中加入以下代码：</p><blockquote><p>Vue.http.options.credentials = true</p></blockquote><p>二、 服务端设置：</p><p>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p><p>1.）Java后台：</p><blockquote><p>/*</p><ul><li>导入包：import javax.servlet.http.HttpServletResponse;</li><li>接口参数中定义：HttpServletResponse response<br>*/<br>response.setHeader(“Access-Control-Allow-Origin”, “<a href="http://www.domain1.com&quot;)" target="_blank" rel="noopener">http://www.domain1.com&quot;)</a>;  // 若有端口需写全（协议+域名+端口）<br>response.setHeader(“Access-Control-Allow-Credentials”, “true”);</li></ul></blockquote><p>2.）Nodejs后台示例：</p><blockquote><p>var http = require(‘http’);<br>var server = http.createServer();<br>var qs = require(‘querystring’);  </p><p>server.on(‘request’, function(req, res) {<br>&nbsp;&nbsp;    var postData = ‘’;  </p><p>&nbsp;&nbsp;    // 数据块接收中<br>&nbsp;&nbsp;    req.addListener(‘data’, function(chunk) {<br>&nbsp;&nbsp;&nbsp;&nbsp;        postData += chunk;<br>&nbsp;&nbsp;    });  </p><p>&nbsp;&nbsp;    // 数据接收完毕<br>&nbsp;&nbsp;    req.addListener(‘end’, function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;        postData = qs.parse(postData);  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;        // 跨域后台设置<br>&nbsp;&nbsp;&nbsp;&nbsp;        res.writeHead(200, {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ‘Access-Control-Allow-Credentials’: ‘true’,     // 后端允许发送Cookie<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ‘Access-Control-Allow-Origin’: ‘<a href="http://www.domain1.com&#39;" target="_blank" rel="noopener">http://www.domain1.com&#39;</a>,    // 允许访问的域（协议+域名+端口）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ‘Set-Cookie’: ‘l=a123456;Path=/;Domain=<a href="http://www.domain2.com;HttpOnly&#39;" target="_blank" rel="noopener">www.domain2.com;HttpOnly&#39;</a>   // HttpOnly:脚本无法读取cookie<br>&nbsp;&nbsp;&nbsp;&nbsp;        });  </p><p>&nbsp;&nbsp;        res.write(JSON.stringify(postData));<br>&nbsp;&nbsp;        res.end();<br>&nbsp;&nbsp;    });<br>});  </p><p>server.listen(‘8080’);<br>console.log(‘Server is running at port 8080…’);  </p></blockquote><h4 id="七、-nginx代理跨域"><a href="#七、-nginx代理跨域" class="headerlink" title="七、 nginx代理跨域"></a>七、 nginx代理跨域</h4><p>1、 nginx配置解决iconfont跨域</p><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p><blockquote><p>location / {<br> add_header Access-Control-Allow-Origin *;<br>}</p></blockquote><p>2、 nginx反向代理接口跨域</p><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>nginx具体配置：</p><blockquote><p>#proxy服务器<br>server {<br>   listen       81;<br>   server_name  <a href="http://www.domain1.com" target="_blank" rel="noopener">www.domain1.com</a>;</p><p>   location / {<br>       proxy_pass   <a href="http://www.domain2.com:8080" target="_blank" rel="noopener">http://www.domain2.com:8080</a>;  #反向代理<br>       proxy_cookie_domain <a href="http://www.domain2.com" target="_blank" rel="noopener">www.domain2.com</a> <a href="http://www.domain1.com" target="_blank" rel="noopener">www.domain1.com</a>; #修改cookie里域名<br>       index  index.html index.htm;</p><pre><code># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*add_header Access-Control-Allow-Credentials true;</code></pre><p>   }<br>}</p></blockquote><p>1.前端代码示例：</p><blockquote><p>var xhr = new XMLHttpRequest();</p><p>// 前端开关：浏览器是否读写cookie<br>xhr.withCredentials = true;</p><p>// 访问nginx中的代理服务器<br>xhr.open(‘get’, ‘<a href="http://www.domain1.com:81/?user=admin&#39;" target="_blank" rel="noopener">http://www.domain1.com:81/?user=admin&#39;</a>, true);<br>xhr.send();</p></blockquote><ol><li>Nodejs后台示例：</li></ol><blockquote><p>var http = require(‘http’);<br>var qs = require(‘querystring’);<br>var server = http.createServer();  </p><p>server.on(‘request’, function(req, res) {<br>&nbsp;&nbsp;    var params = qs.parse(req.url.substring(2));  </p><p>&nbsp;&nbsp;    // 向前台写cookie<br>&nbsp;&nbsp;    res.writeHead(200, {<br>&nbsp;&nbsp;&nbsp;&nbsp;       ‘SetCookie’:’l=a123456;Path=/;Domain=<a href="http://www.domain2.com;HttpOnly&#39;" target="_blank" rel="noopener">www.domain2.com;HttpOnly&#39;</a>   // HttpOnly:脚本无法读取<br>&nbsp;&nbsp;    });  </p><p>&nbsp;&nbsp;    res.write(JSON.stringify(params));<br>&nbsp;&nbsp;    res.end();<br>});  </p><p>server.listen(‘8080’);<br>console.log(‘Server is running at port 8080…’);  </p></blockquote><h4 id="八、-Nodejs中间件代理跨域"><a href="#八、-Nodejs中间件代理跨域" class="headerlink" title="八、 Nodejs中间件代理跨域"></a>八、 Nodejs中间件代理跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发。</p><p>一、 非vue框架的跨域（2次跨域）</p><p>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p><p>1.前端代码示例：</p><blockquote><p>var xhr = new XMLHttpRequest();</p><p>// 前端开关：浏览器是否读写cookie<br>xhr.withCredentials = true;</p><p>// 访问http-proxy-middleware代理服务器<br>xhr.open(‘get’, ‘<a href="http://www.domain1.com:3000/login?user=admin&#39;" target="_blank" rel="noopener">http://www.domain1.com:3000/login?user=admin&#39;</a>, true);<br>xhr.send();</p></blockquote><p>2.中间件服务器：</p><blockquote><p>var express = require(‘express’);<br>var proxy = require(‘http-proxy-middleware’);<br>var app = express();  </p><p>app.use(‘/‘, proxy({<br>&nbsp;&nbsp;    // 代理跨域目标接口<br>&nbsp;&nbsp;    target: ‘<a href="http://www.domain2.com:8080&#39;" target="_blank" rel="noopener">http://www.domain2.com:8080&#39;</a>,<br>&nbsp;&nbsp;    changeOrigin: true,  </p><p>&nbsp;&nbsp;    // 修改响应头信息，实现跨域并允许带cookie<br>&nbsp;&nbsp;   onProxyRes: function(proxyRes, req, res) {<br>&nbsp;&nbsp;&nbsp;&nbsp;        res.header(‘Access-Control-Allow-Origin’, ‘<a href="http://www.domain1.com&#39;)" target="_blank" rel="noopener">http://www.domain1.com&#39;)</a>;<br>&nbsp;&nbsp;&nbsp;&nbsp;       res.header(‘Access-Control-Allow-Credentials’, ‘true’);<br>&nbsp;&nbsp;    },  </p><p>&nbsp;&nbsp;    // 修改响应信息中的cookie域名<br>&nbsp;&nbsp;    cookieDomainRewrite: ‘<a href="http://www.domain1.com&#39;" target="_blank" rel="noopener">www.domain1.com&#39;</a>  // 可以为false，表示不修改<br>}));  </p><p>app.listen(3000);<br>console.log(‘Proxy server is listen at port 3000…’);  </p></blockquote><p>3.Nodejs后台同（六：nginx）</p><p>二、 vue框架的跨域（1次跨域）</p><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p><p>webpack.config.js部分配置：</p><blockquote><p>module.exports = {<br>&nbsp;&nbsp;    entry: {},<br>&nbsp;&nbsp;    module: {},<br>&nbsp;&nbsp;    …<br>&nbsp;&nbsp;    devServer: {<br>&nbsp;&nbsp;&nbsp;&nbsp;        historyApiFallback: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;        proxy: [{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            context: ‘/login’,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            target: ‘<a href="http://www.domain2.com:8080&#39;" target="_blank" rel="noopener">http://www.domain2.com:8080&#39;</a>,  // 代理跨域目标接口<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            changeOrigin: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            cookieDomainRewrite: ‘<a href="http://www.domain1.com&#39;" target="_blank" rel="noopener">www.domain1.com&#39;</a>  // 可以为false，表示不修改<br>&nbsp;&nbsp;&nbsp;&nbsp;        }],<br>&nbsp;&nbsp;        noInfo: true<br>&nbsp;&nbsp;    }<br>}</p></blockquote><h4 id="九、-WebSocket协议跨域"><a href="#九、-WebSocket协议跨域" class="headerlink" title="九、 WebSocket协议跨域"></a>九、 WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1.前端代码：</p><blockquote><p><code>&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;</code>  </p></blockquote><p> <code>&lt;script src=&quot;./socket.io.js&quot;&lt;/script&gt;</code><br>var socket = io(‘<a href="http://www.domain2.com:8080&#39;)" target="_blank" rel="noopener">http://www.domain2.com:8080&#39;)</a>;<br>// 连接成功处理<br>socket.on(‘connect’, function() {<br>&nbsp;&nbsp;    // 监听服务端消息<br>&nbsp;&nbsp;    socket.on(‘message’, function(msg) {<br>&nbsp;&nbsp;&nbsp;&nbsp;       console.log(‘data from server: —&gt; ‘ + msg);<br>&nbsp;&nbsp;    });<br>&nbsp;&nbsp;   // 监听服务端关闭<br>&nbsp;&nbsp;    socket.on(‘disconnect’, function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;        console.log(‘Server socket has closed.’);<br>&nbsp;&nbsp;    });<br>});<br>document.getElementsByTagName(‘input’)[0].onblur =   function() {<br>&nbsp;&nbsp;    socket.send(this.value);<br>};</p><p>2.Nodejs socket后台：</p><blockquote></blockquote><p>var http = require(‘http’);<br>var socket = require(‘socket.io’);<br>// 启http服务</p><blockquote></blockquote><p>var server = http.createServer(function(req, res) {<br>&nbsp;&nbsp;    res.writeHead(200, {  </p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;        ‘Content-type’: ‘text/html’<br>&nbsp;&nbsp;    });<br>&nbsp;&nbsp;    res.end();<br>});  </p></blockquote><p>server.listen(‘8080’);<br>console.log(‘Server is running at port 8080…’);  </p><blockquote></blockquote><p>// 监听socket连接<br>socket.listen(server).on(‘connection’, function(client) {<br>&nbsp;&nbsp;    // 接收信息<br>&nbsp;&nbsp;    client.on(‘message’, function(msg) {<br>&nbsp;&nbsp;&nbsp;&nbsp;        client.send(‘hello：’ + sg);<br>&nbsp;&nbsp;&nbsp;&nbsp;        console.log(‘data from client: —&gt; ‘ + msg);<br>&nbsp;&nbsp;    });  </p><blockquote></blockquote><p>&nbsp;&nbsp;    // 断开处理<br>&nbsp;&nbsp;    client.on(‘disconnect’, function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;        console.log(‘Client socket has closed.’);<br>&nbsp;&nbsp;    });<br>});</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习下跨域&lt;/p&gt;
    
    </summary>
    
      <category term="Web前端" scheme="xumenghao.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="xumenghao.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="跨域" scheme="xumenghao.top/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="postmessage" scheme="xumenghao.top/tags/postmessage/"/>
    
  </entry>
  
  <entry>
    <title>不重视睡眠，谈什么健康？</title>
    <link href="xumenghao.top//posts/4a17b159/"/>
    <id>xumenghao.top//posts/4a17b159/</id>
    <published>2018-03-22T06:19:57.553Z</published>
    <updated>2018-03-21T03:29:20.731Z</updated>
    
    <content type="html"><![CDATA[<p>早睡早起精神好！</p><a id="more"></a><p>James Xu - 中南海保安发来报道</p><p>&nbsp;&nbsp;一个公认的事实是，现在人们越来越重视健康了，所以相关行业蓬勃发展。但事实也证明，许多人尽管重视健康，却不知道如何实现健康的目的，一边定期体检、做疾病筛查，购买健康保险，定期健身，按卡路里和营养搭配三餐，一边却连某些基本的健康法则都很难做到，比如养成良好的作息习惯，保证充足睡眠。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mpic.tiankong.com/4ca/d82/4cad82fca4ddb855da1169593add9bdd/640.jpg@670w" alt="" 玩手机，从小孩子抓起。。。""="" title="">                </div>                <div class="image-caption">"玩手机，从小孩子抓起。。。"</div>            </figure><p>&nbsp;&nbsp;3月21日是第18个世界睡眠日，今年的主题为“规律作息，健康睡眠”。一项针对全国20多个省（区市）的《2018年中国的90后年轻人睡眠指数研究》显示，90后的睡眠均值为66.26（满分为100），普遍睡眠不佳，31.1%的人晚睡晚起，能保持早睡早起作息的只占17.5%，接近1/3的人上午9点后起床。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mpic.tiankong.com/c42/77a/c4277a70b61de213958d8021800f9262/640.jpg@300h" alt="" 早睡早起很难吗""="" title="">                </div>                <div class="image-caption">"早睡早起很难吗"</div>            </figure></p><p>&nbsp;&nbsp;超过80%的90后不能早睡早起，当然不排除一些人是受工作性质所迫，但身边的无数案例告诉我们，至少有很大一部分人是耽于玩乐，舍不得早睡，自然也就很难早起了。玩乐者，有的是捧着手机对着电脑“独乐乐”，有的是跟朋友一起“众乐乐”，无论哪一种，恐怕都没有非熬夜不可的必要性，只是习惯了，缺乏足够动力去调整生物钟。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mpic.tiankong.com/4cc/7f0/4cc7f08e75dffa686cf1506715ab857a/640.jpg@300h" alt="" 工作学习导致不能早睡？""="" title="">                </div>                <div class="image-caption">"工作学习导致不能早睡？"</div>            </figure><p>&nbsp;&nbsp;有人从“年轻时拿命换钱，年老时拿钱换命”这句俗语中看出了年轻人轻忽健康的某种历史经验，以为“都是这么过来的”，这实在是一种错误的经验主义。须知今天的年轻人跟过去的相比，可玩的多了，夜生活多了，运动得少了，生活习惯从整体来看更加不利于健康，现在的青少年儿童近视率高发、身体素质下降，小小年纪得颈椎病、三高，这些都是过去的孩子所没有的。比如，80后就不像90后、00后，在十几岁时大多没有熬夜刷手机的经历，作息时间和视力没有经历过严重“摧残”，“过来人”的经验，有些已经不适用于年轻人了，仅从健康角度来说，等90后、00后步入中年，可能会面临与今天的中年人不同的健康问题和风险。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://mpic.tiankong.com/10f/135/10f135fe1c4667b02bd2fd6314663d05/640.jpg@300h" alt="" 玩手机时间长有害视力""="" title="">                </div>                <div class="image-caption">"玩手机时间长有害视力"</div>            </figure><p>&nbsp;&nbsp;科学研究结果表明，长期缺乏优质睡眠会导致抑郁、焦虑，记忆力下降等等，危害不比忽视疾病筛查、定期体检等等来得小。当今世界上有不少呼吁疾病筛查、关注XX健康的公益项目，当然都很有价值，但对许多人特别是广大网友来说，呼吁“规律作息，健康睡眠”的意义可能更为直接迫切。要真的重视健康，就不能对睡眠这件大事视而不见，否则就别奢谈养生、健身、治未病，因为那跟“可乐加枸杞”“啤酒泡党参”一样，只能是个笑话。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早睡早起精神好！&lt;/p&gt;
    
    </summary>
    
      <category term="健康" scheme="xumenghao.top/categories/%E5%81%A5%E5%BA%B7/"/>
    
    
      <category term="睡眠" scheme="xumenghao.top/tags/%E7%9D%A1%E7%9C%A0/"/>
    
      <category term="健康" scheme="xumenghao.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
  </entry>
  
  <entry>
    <title>“月薪2万”为何招不到工人？</title>
    <link href="xumenghao.top//posts/4a17b158/"/>
    <id>xumenghao.top//posts/4a17b158/</id>
    <published>2018-03-22T06:19:57.540Z</published>
    <updated>2018-03-21T03:29:01.465Z</updated>
    
    <content type="html"><![CDATA[<p>近几日，一篇题为《活久见！月薪2万！广州老板当街大排长龙任人选！90后却不愿干》的文章引发热议。说的是广州开春“招工难”，招工者多，应征者少，甚至有制衣厂老板开出月薪2万的报酬，居然还谈不拢。“月薪2万招不到工人”，这是怎么回事？“用工荒”的真相，到底是什么？</p><a id="more"></a><blockquote><ul><li>老板和工人们陷入了互相算计的囚徒困境——年轻的工人非高薪就不去干活，就算干活也给你磨洋工；而老板的策略就是计件工资，干多少给多少，认为《劳动合同法》过于偏帮劳动者，那就用“高薪”骗你进来，利用《劳动法》执行不严强迫员工加班。  </li><li>工厂里发生的事情，在“高大上”的IT行业也在上演。两者非常类似，相互比较，有助于让都市白领和工人群体深入理解对方。  </li><li>工厂里发生的事情，在“高大上”的IT行业也在上演。两者非常类似，相互比较，有助于让都市白领和工人群体深入理解对方。</li></ul></blockquote><h4 id="“月薪2万”是老板的画饼术，但这种画并不是没有理由"><a href="#“月薪2万”是老板的画饼术，但这种画并不是没有理由" class="headerlink" title="“月薪2万”是老板的画饼术，但这种画并不是没有理由"></a>“月薪2万”是老板的画饼术，但这种画并不是没有理由</h4><hr><p>“月薪2万，90后却不愿干”，这个标题实在太扎眼，毕竟，月薪2万对于一线城市的白领阶层来说，也不能说算少，何况是工厂的工人。于是，读者们纷纷去看文章中的“月薪2万”到底是怎么回事。果然一看很多人就觉得有问题，原文说的是，“‘四线工做一件短袖T恤可以拿到1元，以前是0.8元，还是不满意’，一名揾工者仔细看过姚女士手中的衣服后，价钱没谈拢，默默走开了。老板娘透露，一名熟练的四线工一个月工资能轻松破万，‘厂里雇用的一个靓仔，一天可以做700多件衣服，一个月可拿到2万元’。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//img1.gtimg.com/ninja/1/2018/03/ninja152141988191876.jpeg" alt="" 元宵节过后，广州海珠区的招工者们""="" title="">                </div>                <div class="image-caption">"元宵节过后，广州海珠区的招工者们"</div>            </figure><p>&nbsp;&nbsp;显然，这2万元不是固定工资，而是计件工资，就算是熟手，一天700多件，显然也会累得够呛，而且通过简单的算术就可以知道，“一个月可拿到2万元”的前提是几乎整月无休。难怪一条高赞的网友评论是这么说的，“要么是计件，要么是提成，招人时所谓的高薪都是画的饼。无责任底薪2万招工人试试？”</p><p>&nbsp;&nbsp;还有网友在留言中展示了对老板们更为激烈的态度——“还上万？现在招人的时候特别是工厂，说得天花乱坠，什么五六千的工资，你知道他怎么算的吗？按照一个熟练工，老员工两班倒，再加上你扣除的五险，和它给你缴的五险等等，全部算下来有这么多，这是你累死累活换来的，到手也就4000出头，知道为什么工厂不好招人吗？那是因为工厂不把操作工当人！知道为什么工厂不把人当人吗？那是因为管理层认为中国什么都缺，就不缺人，20岁的招不到我找30的，30的招不到招40的，大学的招不到招高中的，高中的招不到招初中的，没有底线。”</p><p>&nbsp;&nbsp;站在工人一方的网友们的看法，显然与老板们的视角不一样。在老板们看来，“招工难”的原因，是因为现在的年轻人不爱吃苦，嫌累，不像他们的父辈，尤其是第一代进城农民工那么吃苦耐劳。而且认为现在的年轻人也不愿意磨练技术，技校的教育水平差，进厂了也只是为了见见世面，甚至谈恋爱，没有一直在工厂待下去的决心。</p><p>&nbsp;&nbsp;近期一篇流传广泛的解读文章，尤其戳中了老板的内心——“90后的农村员工，绝大多数是喝可乐、吃麦当劳长大的，刚刚出来工作的时候，就遇到新《劳动合同法》的强力保护，根本不关心企业的难处。90后员工只会和老板儿子比生活待遇，然后产生怨恨心态。”言下之意，老板们搞一堆逼你加班还克扣工资的门门道道，也是被逼的，有理由的。非此治不了这些90后员工。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//img1.gtimg.com/ninja/1/2018/03/ninja152141993078370.jpg" alt="" 新一代的农民工，不像老一辈那么爱吃苦，他们有自己的生活""="" title="">                </div>                <div class="image-caption">"新一代的农民工，不像老一辈那么爱吃苦，他们有自己的生活"</div>            </figure><p>&nbsp;&nbsp;然而说老实话，谁愿意吃苦受累了？挑轻松的活干，这是人之常情，而像第一代农民工那么爱吃苦，反而是特殊年代的特殊状态，“他们上有老下有小，不敢歇，也不敢闹，他们拼命干活的动力是子女绝不再进厂当工人，能够改变家族命运。”指望90后农民工继续那么吃苦耐劳，既不现实，也不公平。而且，只要工人这个职业依然难以发固定薪资，发五险一金，依然称不上体面，各种职校、技校就依然处于鄙视链的底端，生源、教育水平就上不来，因此陷入恶性循环。指望像德国那样70%的年轻人上技校？不好意思，别人读完技校出来后都是高级技工，是拿高薪的体面人。</p><p>&nbsp;&nbsp;所以，老板和工人们就陷入了互相算计的囚徒困境——年轻的工人非高薪就不去干活，就算干活也给你磨洋工；而老板的策略就是计件工资，干多少给多少，认为《劳动合同法》过于偏帮劳动者，那就用“高薪”骗你进来，利用《劳动法》执行不严强迫员工加班。互相怨恨，从而陷入死循环。“用工荒”很大程度上就是这么来的。</p><h4 id="IT界的“996”工作制，与“用工荒”产生的原因很类似"><a href="#IT界的“996”工作制，与“用工荒”产生的原因很类似" class="headerlink" title="IT界的“996”工作制，与“用工荒”产生的原因很类似"></a>IT界的“996”工作制，与“用工荒”产生的原因很类似</h4><hr><p>&nbsp;&nbsp;工厂里发生的事情，在“高大上”的IT行业也在上演。两者非常类似，相互比较，有助于让都市白领和工人群体深入理解对方。</p><p>&nbsp;&nbsp;一线、二线城市的许多知名IT企业，发生的事情叫做“996”。即“早上9点上班，晚9点下班，一周上6天班”，刨去每天的2小时午饭休息时间，相当于每周工作60小时，比劳动法规定的40小时要高出50%。通常，公司在创业阶段，或者陷入激烈同业竞争，强调“狼性”的时候就会执行“996”。如此高强度的工作，让很多程序员叫苦不迭，最让人抱怨的是，“996”让人失去了自己的生活，全部身心都投入到了工作上。唯一的安慰，大概只有那不菲的报酬，或许还有加班工资。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//img1.gtimg.com/ninja/1/2018/03/ninja152141996156400.png" alt="" 996”工作制让很多it从业人员感到痛苦""="" title="">                </div>                <div class="image-caption">"996”工作制让很多IT从业人员感到痛苦"</div>            </figure><p>&nbsp;&nbsp;问题来了，为什么以有钱、高薪著称的IT行业，不把薪水调低些，多招些人，而非得以高薪强迫员工“996”呢？</p><p>&nbsp;&nbsp;有很多具体原因。比如若调低薪水，那么根本招不来人才——在“成功狂热”泛滥的当下，很多人就是宁可累成狗也不愿意低薪，因为高薪有太多的意义，意味着行业的认可，意味未来的前景，在整个行业氛围熏陶下，人们只能被动接受“高付出才能有高薪”；又比如行业传染，别人的公司搞996效果不错，那我也学学，于是“狼性”被很多创业企业老板挂在嘴边，而996这种氛围，一旦形成了，很少人有敢按时下班的勇气，就是没事也得熬到9点以后。</p><p>&nbsp;&nbsp;事实上，对于很多老板来说，之所以信奉“996”，其实还是认为只有让员工疯狂加班，才能对得起那份高薪，而如果让员工8小时下班，那么员工肯定会磨洋工不给你好好出力，多招一些人，只会变成多招一些懒汉。所以，在员工看来是“一个人拿两个人的钱干三个人的事”，而在一些老板眼里成为理所当然，在他们看来，这是让少部分精英充分投入干活，效率更高。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//img1.gtimg.com/ninja/1/2018/03/ninja152141999667275.jpg" alt="" 对“狼性文化”的推崇在企业家之间很流行""="" title="">                </div>                <div class="image-caption">"对“狼性文化”的推崇在企业家之间很流行"</div>            </figure><p>&nbsp;&nbsp;老板们的看法并不是毫无道理，之前就有一些国外的调查显示，包括中国在内的东亚人工作时间虽长，但敬业程度，即工作的投入程度并不高。解决之道就是强迫员工加班，而很多员工的对应之道就是消极怠工。从而陷入恶性循环。</p><h4 id="现状不可持续，让员工都能成为“体面人”才能让企业长久地发展"><a href="#现状不可持续，让员工都能成为“体面人”才能让企业长久地发展" class="headerlink" title="现状不可持续，让员工都能成为“体面人”才能让企业长久地发展"></a>现状不可持续，让员工都能成为“体面人”才能让企业长久地发展</h4><hr><p>&nbsp;&nbsp;老板员工们互相算计，陷入囚徒困境，这显然是一种非常糟糕的局面。长此以往，“用工荒”不仅会阻碍社会经济发展，也会阻碍产业升级——熟练工人大量缺乏，职校技校培训水平低，没人看得上眼。年轻人嫌工作无尊严，收入不稳定，总之不体面，即便是农民工二代，也会质疑为啥要继续做这一行，因此许多年轻人纷纷转型做销售、人事等岗位，至少比工人体面。</p><p>&nbsp;&nbsp;这对于IT行业也一样，一旦IT业的发展红利减弱，饼不能越做越大了，就会有越来越多的人质疑为何还要“996”——目前实行“996”工作制的企业，名声已经很不好，但IT企业一旦放弃加班，其竞争力是否会被传统行业跟上呢？不管怎么说，畸形的加班制度只会加剧人心的怨恨，这注定是不能持续的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//img1.gtimg.com/ninja/1/2018/03/ninja152142004282363.jpeg" alt="" 德国的产业工人。让工人阶层更加“体面”，非常重要""="" title="">                </div>                <div class="image-caption">"德国的产业工人。让工人阶层更加“体面”，非常重要"</div>            </figure><p>&nbsp;&nbsp;解决问题的方式，只能是促进整个社会产生共识，加强劳资协商机制，让企业的员工都能成为“体面人”。何谓体面？不用太苦太累，能够每周放两天假，有不错的收入，还有足够的社会保障，即便是“厂弟”、“厂妹”，也会感觉到体面。</p><p>&nbsp;&nbsp;如何做到这一点？确实不容易实现。但一些路径是存在的，比如在严格执行劳动法的基础上，一定程度调整劳动合同法，让资方和劳方的权益都更加受到保障。对此，一些相关的机构该采取切实行动了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近几日，一篇题为《活久见！月薪2万！广州老板当街大排长龙任人选！90后却不愿干》的文章引发热议。说的是广州开春“招工难”，招工者多，应征者少，甚至有制衣厂老板开出月薪2万的报酬，居然还谈不拢。“月薪2万招不到工人”，这是怎么回事？“用工荒”的真相，到底是什么？&lt;/p&gt;
    
    </summary>
    
      <category term="社会" scheme="xumenghao.top/categories/%E7%A4%BE%E4%BC%9A/"/>
    
    
      <category term="话题" scheme="xumenghao.top/tags/%E8%AF%9D%E9%A2%98/"/>
    
      <category term="招工" scheme="xumenghao.top/tags/%E6%8B%9B%E5%B7%A5/"/>
    
      <category term="高薪" scheme="xumenghao.top/tags/%E9%AB%98%E8%96%AA/"/>
    
      <category term="社会" scheme="xumenghao.top/tags/%E7%A4%BE%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="xumenghao.top//posts/4a17b156/"/>
    <id>xumenghao.top//posts/4a17b156/</id>
    <published>2018-03-22T03:58:27.331Z</published>
    <updated>2018-03-22T03:58:27.331Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从输入url到页面展示到底发生了什么</title>
    <link href="xumenghao.top//posts/4a17b160/"/>
    <id>xumenghao.top//posts/4a17b160/</id>
    <published>2018-03-21T02:13:49.000Z</published>
    <updated>2018-03-21T06:31:58.644Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器解析url的过程</p><a id="more"></a><p>阅读目录</p><blockquote><p>1、输入地址<br>2、浏览器查找域名的 IP 地址<br>3、浏览器向 web 服务器发送一个 HTTP 请求<br>4、服务器的永久重定向响应<br>5、浏览器跟踪重定向地址<br>6、服务器处理请求<br>7、服务器返回一个 HTTP 响应  　<br>8、浏览器显示 HTML<br>9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</p></blockquote><p>&nbsp;&nbsp;刚开始写这篇文章还是挺纠结的，因为网上搜索“从输入url到页面展示到底发生了什么”，你可以搜到一大堆的资料。而且面试这道题基本是必考题，二月份面试的时候，虽然知道这个过程发生了什么，不过当面试官一步步追问下去的，很多细节就不太清楚了。  </p><p>&nbsp;&nbsp;最近刚好也在看http协议相关的东西，所以想对这个话题来个深入的总结，本文的目的是通过输入url之后发生的事情来做知识的总结和扩展。所以文章可能会很杂。  </p><p>总的过程大概如下:</p><h4 id="1、输入地址"><a href="#1、输入地址" class="headerlink" title="1、输入地址"></a>1、输入地址</h4><hr><p>&nbsp;&nbsp;当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p><h4 id="2、浏览器查找域名的-IP-地址"><a href="#2、浏览器查找域名的-IP-地址" class="headerlink" title="2、浏览器查找域名的 IP 地址　"></a>2、浏览器查找域名的 IP 地址　</h4><hr><p>1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。  </p><p>2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。  </p><p>3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。  </p><p>4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。  </p><p>5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</p><p>6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。  </p><p>下面这张图很完美的解释了这一过程： </p><h5 id="知识扩展："><a href="#知识扩展：" class="headerlink" title="知识扩展："></a>知识扩展：</h5><blockquote><p>1、什么是DNS？</p></blockquote><p>&nbsp;&nbsp;DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p><p>&nbsp;&nbsp;通俗的讲，我们更习惯于记住一个网站的名字，比如<code>www.baidu.com</code>,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像<code>www.baidu.com</code>等链接。因为，DNS就相当于一个电话本，比如你要找<code>www.baidu.com</code>这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。</p><blockquote><p>2、DNS查询的两种方式：递归查询和迭代查询</p></blockquote><p>1、递归解析</p><p> &nbsp;&nbsp;当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p><p>2、迭代解析</p><p>&nbsp;&nbsp;当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。</p><blockquote><p>3、DNS域名称空间的组织方式</p></blockquote><p> 我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例</p><p>（盗图）</p><blockquote><p>4、DNS负载均衡</p></blockquote><p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p><h4 id="3、浏览器向-web-服务器发送一个-HTTP-请求"><a href="#3、浏览器向-web-服务器发送一个-HTTP-请求" class="headerlink" title="3、浏览器向 web 服务器发送一个 HTTP 请求"></a>3、浏览器向 web 服务器发送一个 HTTP 请求</h4><hr><p>&nbsp;&nbsp;拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p><p>TCP连接如图所示:</p><p>&nbsp;&nbsp;建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。</p><p>客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三 个部分：</p><blockquote><p>请求方法URI协议/版本  </p><p>请求头(Request Header)  </p><p>请求正文：  </p></blockquote><p>下面是一个完整的HTTP请求例子：  </p><blockquote><p>GET/sample.jsp<br>HTTP/1.1   Accept:image/gif.image/jpeg,<em>/</em><br>Accept-Language:zh-cn<br>Connection:Keep-Alive<br>Host:localhost<br>User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)<br>Accept-Encoding:gzip,deflate  </p><p>username=JamesXu&amp;password=1234  </p></blockquote><p>&nbsp;&nbsp;注意：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p><p>（1）请求的第一行是“方法URL议/版本”：GET/sample.jsp HTTP/1.1<br>（2）请求头(Request Header)</p><p>请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。</p><blockquote><p>Accept:image/gif.image/jpeg.<em>/</em><br>Accept-Language:zh-cn<br>Connection:Keep-Alive<br>Host:localhost<br>User-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)<br>Accept-Encoding:gzip,deflate.  </p></blockquote><p>（3）请求正文</p><p>&nbsp;&nbsp;请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：</p><p><code>username=jinqiao&amp;password=1234</code></p><h5 id="知识扩展：-1"><a href="#知识扩展：-1" class="headerlink" title="知识扩展："></a>知识扩展：</h5><p>1）TCP三次握手</p><p>&nbsp;&nbsp;第一次握手：客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认；</p><p>&nbsp;&nbsp;第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。</p><p>&nbsp;&nbsp;第三次握手：客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。</p><p>如图所示：</p><p>2）为什需要三次握手？</p><p>&nbsp;&nbsp;《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”  </p><p>&nbsp;&nbsp;书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接</p><p>&nbsp;&nbsp;假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p><p>3）TCP四次挥手</p><p>&nbsp;&nbsp;第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><p>&nbsp;&nbsp;第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p><p>&nbsp;&nbsp;第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><p>&nbsp;&nbsp;第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p><p>4）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</p><p>&nbsp;&nbsp;这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p><h4 id="4、服务器的永久重定向响应"><a href="#4、服务器的永久重定向响应" class="headerlink" title="4、服务器的永久重定向响应"></a>4、服务器的永久重定向响应</h4><hr><p>&nbsp;&nbsp;服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问<code>http://www.google.com/</code> 而非<code>http://google.com/</code>。</p><p>&nbsp;&nbsp;为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像<code>http://www.yy.com/和http://yy.com/</code>，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。</p><h5 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h5><p>1）301和302的区别。</p><p>&nbsp;&nbsp;301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。</p><p>&nbsp;&nbsp;他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；</p><p>&nbsp;&nbsp;302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301</p><p>2）重定向原因：  </p><p>（1）网站调整（如改变网页目录结构）；<br>（2）网页被移到一个新地址；<br>（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。  </p><p>&nbsp;&nbsp;这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p><p>3）什么时候进行301或者302跳转呢？</p><p>&nbsp;&nbsp;当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。<br>清晰明确而言：使用301跳转的大概场景如下：</p><p>1、域名到期不想续费（或者发现了更适合网站的域名），想换个域名。<br>2、在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。<br>3、空间服务器不稳定，换空间的时候。  </p><h4 id="5、浏览器跟踪重定向地址"><a href="#5、浏览器跟踪重定向地址" class="headerlink" title="5、浏览器跟踪重定向地址"></a>5、浏览器跟踪重定向地址</h4><hr><p>&nbsp;&nbsp;现在浏览器知道了 <code>&quot;http://www.google.com/&quot;</code>才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的</p><h4 id="6、服务器处理请求"><a href="#6、服务器处理请求" class="headerlink" title="6、服务器处理请求"></a>6、服务器处理请求</h4><hr><p>&nbsp;&nbsp;经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？</p><p>&nbsp;&nbsp;后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。</p><p>&nbsp;&nbsp;一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p><p>如图所示：</p><p>&nbsp;&nbsp;通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然，这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。</p><h5 id="扩展阅读："><a href="#扩展阅读：" class="headerlink" title="扩展阅读："></a>扩展阅读：</h5><p>1）什么是反向代理？</p><p>&nbsp;&nbsp;客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。</p><h4 id="7、服务器返回一个-HTTP-响应"><a href="#7、服务器返回一个-HTTP-响应" class="headerlink" title="7、服务器返回一个 HTTP 响应　"></a>7、服务器返回一个 HTTP 响应　</h4><hr><p>&nbsp;&nbsp;经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。</p><p>HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p><blockquote><p>状态行</p><p>响应头(Response Header)</p><p>响应正文</p></blockquote><blockquote><p>HTTP/1.1 200 OK<br>Date: Sat, 31 Dec 2005 23:59:59 GMT<br>Content-Type: text/html;charset=ISO-8859-1   Content- Length: 122<br>＜html＞<br>＜head＞<br>＜title＞http＜/title＞<br>＜/head＞<br>＜body＞<br>＜!– body goes here –＞<br>＜/body＞<br>＜/html＞  </p></blockquote><h5 id="状态行："><a href="#状态行：" class="headerlink" title="状态行："></a>状态行：</h5><p>&nbsp;&nbsp;状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p><p>格式:    HTTP-Version Status-Code Reason-Phrase CRLF</p><p>例如:    HTTP/1.1 200 OK \r\n</p><p>– 协议版本：是用http1.0还是其他版本  </p><p>– 状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok  </p><p>– 状态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。如下  </p><p>1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。</p><p>100 Continue</p><p>101 Switching Protocols</p><p>2xx：成功状态码，表示服务器已成功接收到请求并进行处理。200 OK 表示客户端请求成功</p><p>204 No Content 成功，但不返回任何实体的主体部分</p><p>206 Partial Content 成功执行了一个范围（Range）请求</p><p>3xx：重定向状态码，表示服务器要求客户端重定向。</p><p>301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL</p><p>302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源</p><p>303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源</p><p>304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存</p><p>307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现</p><p>4xx：客户端错误状态码，表示客户端的请求有非法内容。</p><p>400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解</p><p>401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用</p><p>403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因</p><p>404 Not Found 请求的资源不存在，例如，输入了错误的URL</p><p>5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。</p><p>500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求</p><p>503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</p><h5 id="响应头："><a href="#响应头：" class="headerlink" title="响应头："></a>响应头：</h5><p>响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔，典型的响应头有：</p><h5 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h5><p>&nbsp;&nbsp;包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文：</p><h4 id="8、浏览器显示-HTML"><a href="#8、浏览器显示-HTML" class="headerlink" title="8、浏览器显示 HTML"></a>8、浏览器显示 HTML</h4><hr><p>&nbsp;&nbsp;在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括：</p><p>&nbsp;&nbsp;解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</p><p>&nbsp;&nbsp;浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。</p><p>&nbsp;&nbsp;解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。</p><p>&nbsp;&nbsp;DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。</p><p>&nbsp;&nbsp;页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p><p>&nbsp;&nbsp;当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。</p><p>JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。</p><p>&nbsp;&nbsp;JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。具体的过程可以看我这篇文章：点击这里</p><h4 id="9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）"><a href="#9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）" class="headerlink" title="9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）"></a>9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</h4><hr><p>&nbsp;&nbsp;其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接：</p><blockquote><p>图片：<a href="http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif" target="_blank" rel="noopener">http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif</a></p><p>CSS式样表：<a href="http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css" target="_blank" rel="noopener">http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css</a></p><p>JavaScript 文件：<a href="http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js" target="_blank" rel="noopener">http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js</a></p></blockquote><p>&nbsp;&nbsp;这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…</p><p>&nbsp;&nbsp;不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中  </p><p>————分割线————</p><p>&nbsp;&nbsp;至此，从输入url到页面展示的过程终于整理完了。本文前前后后整理了差不多一个星期，当然，网上有很多文章的顺序可能跟本文不太一样，也是可以的。</p><p>&nbsp;&nbsp;如今已离开呆了一年的大YY，进入了另一家公司，有很多东西在后面等着学习，有点小压力的同时也有很强烈的兴奋，哈哈。愿你在金三银四里找到满意的工作，干巴爹。</p><p>当然，文笔有限，有误之处，欢迎指出，本文参考了很多的文章，不过很多文章的链接不记得了，所以只列出了下面三个参考链接。</p><blockquote><p>参考文献：<br><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a><br><a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/" target="_blank" rel="noopener">http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/</a><br><a href="http://zrj.me/archives/589" target="_blank" rel="noopener">http://zrj.me/archives/589</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器解析url的过程&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器" scheme="xumenghao.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="HTML" scheme="xumenghao.top/tags/HTML/"/>
    
      <category term="浏览器解析" scheme="xumenghao.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
